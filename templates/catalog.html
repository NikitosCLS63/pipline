{% extends "base.html" %}
{% load static %}

{% block content %}
    <link rel="stylesheet" href="{% static 'css/catalog.css' %}">
    

    <div class="catalog-header">
        <h1>üì¶ –ö–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤</h1>
    </div>

    <div class="catalog-layout">
        <!-- –ë–æ–∫–æ–≤–∞—è –ø–∞–Ω–µ–ª—å —Ñ–∏–ª—å—Ç—Ä–æ–≤ -->
        <aside class="sidebar-filters">
            <div class="filter-title">
                <span>–§–∏–ª—å—Ç—Ä—ã</span>
                <button class="filter-reset" onclick="resetAllFilters()">–°–±—Ä–æ—Å–∏—Ç—å</button>
            </div>

            <!-- –¶–µ–Ω–∞ -->
            <div class="filter-group">
                <div class="filter-header" onclick="toggleFilterGroup(this)">
                    <span>–¶–µ–Ω–∞</span>
                    <div class="arrow"></div>
                </div>
                <div class="filter-options">
                    <div class="price-range">
                        <input type="number" id="price-min" placeholder="–û—Ç" min="0">
                        <input type="number" id="price-max" placeholder="–î–æ" min="0">
                    </div>
                </div>
            </div>

            <!-- –ù–∞–ª–∏—á–∏–µ -->
            <div class="filter-group">
                <div class="filter-header" onclick="toggleFilterGroup(this)">
                    <span>–ù–∞–ª–∏—á–∏–µ</span>
                    <div class="arrow"></div>
                </div>
                <div class="filter-options">
                    <label><input type="checkbox" value="in-stock" class="filter-checkbox"> –í –Ω–∞–ª–∏—á–∏–∏ <span class="filter-count">(0)</span></label>
                    <label><input type="checkbox" value="out-of-stock" class="filter-checkbox"> –ù–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏ <span class="filter-count">(0)</span></label>
                </div>
            </div>

            <!-- –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ñ–∏–ª—å—Ç—Ä—ã –∏–∑ specifications -->
            <div id="dynamic-filters"></div>

            <button class="apply-filters-btn" onclick="applyFilters()">–ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã</button>
        </aside>

        <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç –∫–∞—Ç–∞–ª–æ–≥–∞ -->
        <div class="catalog-content">
            <div class="top-bar">
                <div class="category-selector" id="category-selector">
                    <!-- Categories will be injected here -->
                </div>
                <div style="flex: 1; position: relative;">
                    <input type="text" id="search" placeholder="–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é..." class="search-input">
                    <div style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-size: 10px; color: #6c757d;">
                        <kbd style="background: #e9ecef; padding: 2px 6px; border-radius: 3px; font-size: 10px;">/</kbd>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 11px; color: #6c757d; margin-bottom: 15px;">
                <span>–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: </span>
                <span style="margin-left: 8px;"><kbd style="background: #e9ecef; padding: 2px 6px; border-radius: 3px; font-size: 10px;">/</kbd> - –ü–æ–∏—Å–∫</span>
            </div>

            <div id="products-container" class="products-grid">
                <div class="empty-message">–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤...</div>
            </div>
        </div>
    </div>

    <!-- Modal –¥–ª—è —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ -->
    <div id="specs-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <style>
                /* Modal custom styles */
                #specs-modal .modal-content{max-width:980px;padding:1.25rem;border-radius:12px}
                .modal-header-info{display:flex;align-items:center;gap:1rem;margin-bottom:0.75rem}
                .modal-brand-logo{width:56px;height:56px;object-fit:contain;border-radius:8px;background:#fff;padding:6px;border:1px solid rgba(0,0,0,0.06)}
                .modal-brand-name{font-size:1rem;color:var(--text-secondary);font-weight:600}
                .modal-rating{font-size:0.95rem;color:#666;margin-top:2px}
                .modal-actions{display:flex;gap:0.5rem}
                .modal-action-btn{background:#fff;color:#222;border:1px solid rgba(0,0,0,0.08);padding:0.45rem 0.7rem;border-radius:8px;cursor:pointer;display:inline-flex;align-items:center;gap:0.5rem}
                .modal-action-btn.primary{background:#ff8c42;color:#fff;border-color:transparent}
                .modal-action-btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06)}
                .modal-action-btn .icon{font-size:1.05rem}
                .price-stock-row{display:flex;gap:1rem;align-items:center;margin-bottom:1rem}
                .price-block strong{color:var(--text-secondary)}
                .price-value{font-size:1.3rem;color:#ff8c42;font-weight:700}
            </style>

            <div class="modal-header-info">
                <img id="modal-brand-logo" class="modal-brand-logo" src="/static/images/no-image.png" alt="–ë—Ä–µ–Ω–¥">
                <div style="flex:1;min-width:0">
                    <div id="modal-brand-name" class="modal-brand-name"></div>
                    <div id="modal-rating" class="modal-rating"></div>
                </div>
            </div>

            <div class="modal-gallery">
                <div class="modal-main-image">
                    <img id="modal-main-img" src="" alt="–¢–æ–≤–∞—Ä">
                </div>
                <div class="modal-thumbnails" id="modal-thumbnails"></div>
            </div>

            <h2 id="modal-product-name" style="margin-bottom: 0.5rem;"></h2>
            <div class="price-stock-row">
                <div class="price-block">
                    <strong style="color: var(--text-secondary);">–¶–µ–Ω–∞:</strong>
                    <div id="modal-price" class="price-value"></div>
                </div>
                <div class="stock-block">
                    <strong style="color: var(--text-secondary);">–í –Ω–∞–ª–∏—á–∏–∏:</strong>
                    <div id="modal-stock" style="font-size: 1.1rem;"></div>
                </div>
                <div style="display:flex;align-items:center;gap:1rem;">
                    <div id="modal-rating-stars" style="font-size:1.2rem;color:#ffa500;">‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ (5/5)</div>
                </div>
                <div style="margin-left:auto;display:flex;gap:0.5rem;align-items:center;">
                    <button id="modal-fav-btn" class="modal-action-btn ghost" data-product-id="" onclick="toggleFavorite(event, '')"><span class="icon">ü§ç</span></button>
                    <button id="modal-cart-btn" class="modal-action-btn primary" data-product-id="" onclick="addToCart(event, '')"><span class="icon">üõí</span></button>
                    <button id="modal-compare-btn" class="modal-action-btn" data-product-id="" onclick="toggleCompare(event)"><span class="icon">‚öñÔ∏è</span></button>
                </div>
            </div>

            <h3 style="margin-bottom: 1rem; margin-top: 1.5rem;">–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:</h3>
            <div id="specs-container" class="specs-grid"></div>

            <div style="margin-top:2rem;display:flex;gap:1rem;">
                <button id="modal-reviews-btn" class="modal-action-btn" onclick="openReviewsModal()" style="background:#1976d2;color:#fff;border:0;padding:0.5rem 1rem;">–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –æ—Ç–∑—ã–≤—ã</button>
            </div>
        </div>
    </div>

    <!-- Reviews Modal -->
    <div id="reviews-modal" class="modal" style="display:none;">
        <div class="modal-content" style="max-width:600px;">
            <button class="modal-close" onclick="closeReviewsModal()">&times;</button>
            <h2>–û—Ç–∑—ã–≤—ã –æ —Ç–æ–≤–∞—Ä–µ</h2>
            <div id="reviews-list" style="max-height:400px;overflow-y:auto;margin-top:1rem;"></div>
        </div>
    </div>

    <script src="/static/js/theme-toggle.js"></script>
    <script>
        let allProducts = [];
        let currentProduct = null;

        // === PER-USER CART AND COMPARISON KEYS ===
        function getCartKey() {
            const token = localStorage.getItem('access_token');
            let customerId = null;
            if (token) {
                try {
                    const parts = token.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        customerId = payload.customer_id || payload.user_id;
                    }
                } catch (e) {}
            }
            return customerId ? `cart_${customerId}` : 'cart';
        }

        function getCompareKey() {
            const token = localStorage.getItem('access_token');
            let customerId = null;
            if (token) {
                try {
                    const parts = token.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        customerId = payload.customer_id || payload.user_id;
                    }
                } catch (e) {}
            }
            return customerId ? `compare_${customerId}` : 'compare';
        }

        function getFavoritesKey() {
            const token = localStorage.getItem('access_token');
            let customerId = null;
            if (token) {
                try {
                    const parts = token.split('.');
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        customerId = payload.customer_id || payload.user_id;
                    }
                } catch (e) {}
            }
            return customerId ? `favorites_${customerId}` : 'favorites';
        }

        // Templates auto-loading
        const templateFiles = ['keyboard.json','laptop.json','monitor.json','mouse.json'];
        const templatesMap = {}; // type -> set(keys)
        const keyLabels = {
            // default human-friendly labels (Russian)
            'brand': '–ë—Ä–µ–Ω–¥', 'model': '–ú–æ–¥–µ–ª—å', 'cpu': '–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä', 'gpu': '–í–∏–¥–µ–æ–∫–∞—Ä—Ç–∞', 'ram': '–û–ó–£', 'storage': '–•—Ä–∞–Ω–∏–ª–∏—â–µ', 'display': '–≠–∫—Ä–∞–Ω',
            'ports': '–ü–æ—Ä—Ç—ã', 'battery': '–ë–∞—Ç–∞—Ä–µ—è', 'layout': '–§–æ—Ä–º–∞—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã', 'backlight': '–ü–æ–¥—Å–≤–µ—Ç–∫–∞', 'mechanical': '–ú–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∞—è',
            'connection': '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ', 'dpi': 'DPI', 'buttons': '–ö–Ω–æ–ø–∫–∏',
            'resolution': '–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ', 'refresh_rate': '–ß–∞—Å—Ç–æ—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è', 'panel_type': '–¢–∏–ø –º–∞—Ç—Ä–∏—Ü—ã', 'size': '–î–∏–∞–≥–æ–Ω–∞–ª—å (–¥—é–π–º)',
            'diagonal': '–î–∏–∞–≥–æ–Ω–∞–ª—å', 'matrix': '–ú–∞—Ç—Ä–∏—Ü–∞',
            'type': '–¢–∏–ø', 'category': '–ö–∞—Ç–µ–≥–æ—Ä–∏—è', 'category_name': '–ö–∞—Ç–µ–≥–æ—Ä–∏—è', 'template': '–¢–∏–ø —Ç–æ–≤–∞—Ä–∞',
            'price': '–¶–µ–Ω–∞', 'stock_quantity': '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ –Ω–∞–ª–∏—á–∏–∏', 'status': '–°—Ç–∞—Ç—É—Å'
        };

        let serverPaged = false;
        let serverPageCount = 1;

        async function fetchTemplates() {
            try {
                for (const fname of templateFiles) {
                    try {
                        const res = await fetch(`/static/json_templates/${fname}`);
                        if (!res.ok) continue;
                        const json = await res.json();
                        const ttype = (json.type || '').toString().toLowerCase();
                        const keys = Object.keys(json.specs || {});
                        templatesMap[ttype] = new Set(keys);
                        // merge labels
                        keys.forEach(k => {
                            if (!keyLabels[k]) {
                                // humanize fallback
                                keyLabels[k] = k.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                            }
                        });
                    } catch (e) {
                        console.warn('Failed to load template', fname, e);
                    }
                }
            } catch (e) {
                console.error('Error loading templates', e);
            }
        }

        function getLabelForKey(k) { return keyLabels[k] || k; }

        // Try to detect server-side pagination support
        async function detectServerPagination() {
            try {
                const token = localStorage.getItem('access_token');
                const headers = token ? { 'Authorization': `Bearer ${token}` } : {};
                const r = await fetch('/api/products/?page=1', { headers });
                if (!r.ok) return false;
                const data = await r.json();
                if (data && typeof data === 'object' && Array.isArray(data.results)) {
                    serverPaged = true;
                    serverPageCount = Math.max(1, Math.ceil((data.count || data.results.length) / pageSize));
                    allProducts = data.results;
                    renderProducts(allProducts);
                    generateCategorySelector();
                    generateDynamicFilters();
                    updateFilterCounts();
                    return true;
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        async function fetchServerPage(page=1) {
            const token = localStorage.getItem('access_token');
            const headers = token ? { 'Authorization': `Bearer ${token}` } : {};
            const resp = await fetch(`/api/products/?page=${page}`, { headers });
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            const data = await resp.json();
            if (Array.isArray(data.results)) {
                allProducts = data.results;
                serverPageCount = Math.max(1, Math.ceil((data.count || data.results.length) / pageSize));
                return allProducts;
            }
            throw new Error('Unexpected paged response');
        }

        async function loadFavorites() {
            // –ó–∞–≥—Ä—É–∂–∞–µ—Ç favorites —Å API –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç localStorage
            try {
                const token = localStorage.getItem('access_token');
                if (!token) {
                    console.log('[FAVORITES] No token, skipping API load');
                    return;
                }
                
                console.log('[FAVORITES] Loading from API...');
                const response = await fetch('/api/wishlists/', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('[FAVORITES] API response status:', response.status);
                
                if (response.ok) {
                    const wishlists = await response.json();
                    console.log('[FAVORITES] Got wishlists:', wishlists);
                    const favoriteIds = wishlists.map(w => w.product);
                    console.log('[FAVORITES] Favorite product IDs:', favoriteIds);
                    localStorage.setItem(getFavoritesKey(), JSON.stringify(favoriteIds));
                } else {
                    console.warn('[FAVORITES] API error status:', response.status);
                    const text = await response.text();
                    console.warn('[FAVORITES] Error response:', text);
                }
            } catch (error) {
                console.warn('[FAVORITES] Error loading favorites:', error);
            }
        }

        async function loadProducts() {
            try {
                // –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∂–∞–µ–º favorites —Å API
                await loadFavorites();
                
                await fetchTemplates();

                // first check if server supports pagination
                const supported = await detectServerPagination();
                if (supported) return; // detectServerPagination already rendered first page

                // Fallback: fetch full list
                const token = localStorage.getItem('access_token');
                const headers = token ? { 'Authorization': `Bearer ${token}` } : {};
                const response = await fetch('/api/products/', { headers });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const products = await response.json();
                if (!Array.isArray(products)) throw new Error('Invalid response format');
                allProducts = products;

                renderProducts(allProducts);
                generateCategorySelector();
                generateDynamicFilters();
                updateFilterCounts();
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ–≤–∞—Ä–æ–≤:', error);
                document.getElementById('products-container').innerHTML = '<div class="empty-message">‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ç–æ–≤–∞—Ä–æ–≤. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å.</div>';
            }
        }

        function renderProducts(products) {
            const container = document.getElementById('products-container');
            
            if (products.length === 0) {
                    container.innerHTML = '<div class="empty-message">–¢–æ–≤–∞—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
                    return;
                }

                // Pagination: calculate slice for current page
                const startIndex = (currentPage - 1) * pageSize;
                const endIndex = startIndex + pageSize;
                const pageProducts = products.slice(startIndex, endIndex);

                container.innerHTML = pageProducts.map(product => {
                const images = getValidImages(product.images);
                const isLiked = JSON.parse(localStorage.getItem(getFavoritesKey()) || '[]').includes(product.product_id);
                const inCart = isInCart(product.product_id);
                const ratingStars = product.rating ? '‚òÖ'.repeat(Math.round(product.rating)) + '‚òÜ'.repeat(5 - Math.round(product.rating)) : '';
                
                return `
                    <div class="product-card" onclick="openModal('${product.product_id}')">
                        <div class="product-image-container">
                            <img src="${images[0] || '/static/images/no-image.png'}" alt="${product.product_name}" class="product-image">
                            ${images.length > 1 ? `
                                <div class="image-nav">
                                    <button onclick="event.stopPropagation(); changeImage(event, -1, '${product.product_id}')">‚ùÆ</button>
                                    <button onclick="event.stopPropagation(); changeImage(event, 1, '${product.product_id}')">‚ùØ</button>
                                </div>
                            ` : ''}
                        </div>
                        
                        <div class="product-info">
                            <h3 class="product-name" title="${product.product_name}">${product.product_name}</h3>
                            ${product.rating ? `<div class="product-rating" style="color: #ffa500; font-size: 0.9rem; margin: 0.3rem 0;">${ratingStars} ${product.rating.toFixed(1)}/5</div>` : ''}
                            <div class="product-stock ${product.stock_quantity < 5 ? 'low' : ''}">
                                ${product.stock_quantity > 0 ? `${product.stock_quantity} –≤ –Ω–∞–ª–∏—á–∏–∏` : '–ù–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏'}
                            </div>
                            
                            <div class="product-footer">
                                <div class="product-price">${formatPrice(product.price)} ‚ÇΩ</div>
                                <button class="favorite-btn ${isLiked ? 'liked' : ''}" data-product-id="${product.product_id}" onclick="toggleFavorite(event, '${product.product_id}')">
                                    ${isLiked ? '‚ù§Ô∏è' : 'ü§ç'}
                                </button>
                                <button class="add-to-cart-btn ${inCart ? 'in-cart' : ''}" data-product-id="${product.product_id}" onclick="addToCart(event, '${product.product_id}')">
                                    ${inCart ? '‚úì' : 'üõí'}
                                </button>
                            </div>
                            <button class="review-btn" onclick="event.stopPropagation(); openProductReviews('${product.product_id}')" style="width: 100%; margin-top: 0.5rem; padding: 0.4rem; background: #f0f0f0; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">–û—Ç–∑—ã–≤—ã</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Update all cart buttons after rendering
            updateAllCartButtons();

            renderPagination(products.length);
        }

        // Pagination helpers
        let currentPage = 1;
        const pageSize = 9; // 3x3 grid

        function renderPagination(totalItems) {
            const totalPages = Math.max(1, Math.ceil(totalItems / pageSize));
            const existing = document.getElementById('pagination');
            if (existing) existing.remove();

            const pagination = document.createElement('div');
            pagination.id = 'pagination';
            pagination.className = 'pagination';

            const prev = document.createElement('button');
            prev.textContent = '‚Äπ';
            prev.disabled = currentPage === 1;
            prev.onclick = () => { if (currentPage > 1) { currentPage--; applyFilters(); } };
            pagination.appendChild(prev);

            for (let i = 1; i <= totalPages; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = (i === currentPage) ? 'active' : '';
                btn.onclick = (() => { const page = i; return () => { currentPage = page; applyFilters(); }; })();
                pagination.appendChild(btn);
            }

            const next = document.createElement('button');
            next.textContent = '‚Ä∫';
            next.disabled = currentPage === totalPages;
            next.onclick = () => { if (currentPage < totalPages) { currentPage++; applyFilters(); } };
            pagination.appendChild(next);

            document.querySelector('.catalog-content').appendChild(pagination);
        }

        function getValidImages(images) {
            if (!images) return [];

            const result = [];
            const seen = new Set();

            const addImage = (img) => {
                if (typeof img === 'string' && !img.startsWith('blob:') && img.trim() && !seen.has(img.trim())) {
                    if (img.trim().startsWith('[')) {
                        try {
                            const parsed = JSON.parse(img.trim());
                            if (Array.isArray(parsed)) {
                                parsed.forEach(p => {
                                    if (p && typeof p === 'string' && !p.startsWith('blob:') && !seen.has(p.trim())) {
                                        seen.add(p.trim());
                                        result.push(p.trim());
                                    }
                                });
                            }
                        } catch (e) {
                            seen.add(img.trim());
                            result.push(img.trim());
                        }
                    } else {
                        seen.add(img.trim());
                        result.push(img.trim());
                    }
                }
            };

            if (Array.isArray(images)) {
                images.forEach(addImage);
            } else if (typeof images === 'string') {
                addImage(images);
            }

            return result.slice(0, 5);
        }

        let imageIndices = {};

        function changeImage(event, direction, productId) {
            event.stopPropagation();
            const card = event.target.closest('.product-card');
            const images = getValidImages(getProductById(productId).images);
            
            if (images.length === 0) return;
            
            if (!imageIndices[productId]) imageIndices[productId] = 0;
            imageIndices[productId] = (imageIndices[productId] + direction + images.length) % images.length;
            
            const img = card.querySelector('.product-image');
            img.src = images[imageIndices[productId]];
        }

        function formatPrice(price) {
            return new Intl.NumberFormat('ru-RU').format(Math.round(price));
        }

        function addToCart(event, productId) {
            event.stopPropagation();
            
            // Ensure productId is an integer
            const id = parseInt(productId);
            const product = getProductById(id);
            
            if (!product) {
                console.error('Product not found:', id);
                return;
            }
            
            const qty = 1;
            
            let cart = JSON.parse(localStorage.getItem(getCartKey()) || '[]');
            const existing = cart.find(item => item.product_id === id);
            
            if (existing) {
                existing.quantity = Math.min(existing.quantity + qty, product.stock_quantity);
            } else {
                cart.push({ product_id: id, quantity: qty });
            }
            
            localStorage.setItem(getCartKey(), JSON.stringify(cart));
            
            const btn = event.target;
            // Immediately update button state
            btn.classList.add('in-cart');
            btn.textContent = '‚úì';
            
            // Also update all other buttons for this product immediately
            updateCartButtonsImmediate(id);
            
            // Reset button after 2 seconds
            setTimeout(() => {
                btn.classList.remove('in-cart');
                btn.textContent = 'üõí';
                // Update all buttons to show they're in cart
                updateAllCartButtons();
            }, 2000);
            
            // Update cart counter in header
            updateCartCounter();
        }
        
        function updateCartButtonsImmediate(productId) {
            // Ensure productId is an integer for consistency
            const id = parseInt(productId);
            
            // Update all buttons in product grid for this product
            document.querySelectorAll('.add-to-cart-btn').forEach(btn => {
                if (parseInt(btn.dataset.productId) === id) {
                    btn.classList.add('in-cart');
                    btn.textContent = '‚úì';
                }
            });
            
            // Update button in modal if it's open and showing this product
            const modalBtn = document.getElementById('modal-cart-btn');
            if (modalBtn && parseInt(modalBtn.dataset.productId) === id) {
                modalBtn.classList.add('in-cart');
                modalBtn.innerHTML = '<span class="icon">‚úì</span>';
            }
        }
        
        function isInCart(productId) {
            const cart = JSON.parse(localStorage.getItem(getCartKey()) || '[]');
            const id = parseInt(productId);
            return cart.some(item => item.product_id === id);
        }
        
        function updateAllCartButtons() {
            const cart = JSON.parse(localStorage.getItem(getCartKey()) || '[]');
            const productIdsInCart = cart.map(item => item.product_id);
            
            // Update all add-to-cart buttons
            document.querySelectorAll('.add-to-cart-btn').forEach(btn => {
                const productId = parseInt(btn.dataset.productId);
                if (productIdsInCart.includes(productId)) {
                    btn.classList.add('in-cart');
                    btn.textContent = '‚úì';
                } else {
                    btn.classList.remove('in-cart');
                    btn.textContent = 'üõí';
                }
            });
        }

        function toggleFavorite(event, productId) {
            event.stopPropagation();
            // Determine button element (target may be inner span)
            let btn = event.currentTarget || event.target;
            if (btn && btn.tagName !== 'BUTTON') {
                btn = btn.closest('button');
            }

            // Determine product id: prefer explicit arg, then data attribute on button
            let id = productId || (btn && (btn.dataset.productId || btn.getAttribute('data-product-id')));
            if (!id) return;
            id = parseInt(id);

            console.log('[FAVORITE] Toggle favorite for product:', id);

            let favorites = JSON.parse(localStorage.getItem(getFavoritesKey()) || '[]');
            const already = favorites.includes(id);
            
            // Get token
            const token = localStorage.getItem('access_token');
            
            if (!token) {
                console.log('[FAVORITE] No token, using localStorage only');
                // If not authenticated, just update localStorage
                if (already) {
                    favorites = favorites.filter(x => x !== id);
                } else {
                    favorites.push(id);
                }
                localStorage.setItem(getFavoritesKey(), JSON.stringify(favorites));
                
                // Update button UI
                if (btn) {
                    const icon = btn.querySelector('.icon');
                    if (icon) {
                        icon.textContent = already ? 'ü§ç' : '‚ù§Ô∏è';
                    } else {
                        btn.textContent = already ? 'ü§ç' : '‚ù§Ô∏è';
                    }
                    btn.classList.toggle('liked', !already);
                }
                return;
            }
            
            // For authenticated users, sync with API
            const endpoint = already ? '/api/wishlists/remove_from_wishlist/' : '/api/wishlists/add_to_wishlist/';
            console.log('[FAVORITE] Calling endpoint:', endpoint);
            
            fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ product_id: id })
            })
            .then(response => {
                console.log('[FAVORITE] Response status:', response.status);
                
                if (response.ok) {
                    console.log('[FAVORITE] Success!');
                    // Update localStorage
                    if (already) {
                        favorites = favorites.filter(x => x !== id);
                    } else {
                        favorites.push(id);
                    }
                    localStorage.setItem(getFavoritesKey(), JSON.stringify(favorites));
                    
                    // Extract customer_id from token and save to cookie for favorites page
                    try {
                        const parts = token.split('.');
                        if (parts.length === 3) {
                            const payload = JSON.parse(atob(parts[1]));
                            const customerId = payload.customer_id || payload.user_id;
                            if (customerId) {
                                // Set cookie with 28 days (4 weeks) expiration
                                const date = new Date();
                                date.setTime(date.getTime() + (28 * 24 * 60 * 60 * 1000));
                                document.cookie = `customer_id=${customerId}; path=/; expires=${date.toUTCString()}`;
                                console.log('[FAVORITE] Saved customer_id to cookie:', customerId);
                            }
                        }
                    } catch (e) {
                        console.warn('[FAVORITE] Could not extract customer_id from token');
                    }
                    
                    // Update button UI
                    if (btn) {
                        const icon = btn.querySelector('.icon');
                        if (icon) {
                            icon.textContent = already ? 'ü§ç' : '‚ù§Ô∏è';
                        } else {
                            btn.textContent = already ? 'ü§ç' : '‚ù§Ô∏è';
                        }
                        btn.classList.toggle('liked', !already);
                    }
                } else {
                    console.error('[FAVORITE] Error status:', response.status);
                    response.text().then(text => console.error('[FAVORITE] Error response:', text));
                    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ (—Å—Ç–∞—Ç—É—Å: ' + response.status + ')');
                }
            })
            .catch(error => {
                console.error('[FAVORITE] Network error:', error);
                alert('–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ');
            });
        }
        
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function getProductById(productId) {
            return allProducts.find(p => p.product_id === parseInt(productId));
        }

        function openModal(productId) {
            currentProduct = getProductById(productId);
            
            const validImages = getValidImages(currentProduct.images);
            document.getElementById('modal-main-img').src = validImages[0] || '/static/images/no-image.png';
            
            document.getElementById('modal-product-name').textContent = currentProduct.product_name;
            document.getElementById('modal-price').textContent = formatPrice(currentProduct.price) + ' ‚ÇΩ';
            document.getElementById('modal-stock').textContent = `${currentProduct.stock_quantity} —à—Ç.`;
            
            // Brand and rating
            document.getElementById('modal-brand-logo').src = currentProduct.brand_logo_url || '/static/images/no-image.png';
            document.getElementById('modal-brand-name').textContent = currentProduct.brand_name || '';
            document.getElementById('modal-rating').textContent = currentProduct.rating ? `–†–µ–π—Ç–∏–Ω–≥: ${currentProduct.rating} / 5` : '';
            
            // Modal action buttons setup (set product id and handlers)
            const compareBtn = document.getElementById('modal-compare-btn');
            const favBtn = document.getElementById('modal-fav-btn');
            const cartBtn = document.getElementById('modal-cart-btn');
            
            compareBtn.dataset.productId = currentProduct.product_id;
            favBtn.dataset.productId = currentProduct.product_id;
            cartBtn.dataset.productId = currentProduct.product_id;
            
            updateCompareButton(compareBtn, currentProduct.product_id);
            
           
            const token = localStorage.getItem('access_token');
            let favorites = JSON.parse(localStorage.getItem(getFavoritesKey()) || '[]');
            let isLiked = favorites.includes(currentProduct.product_id);
            
            const favIcon = favBtn.querySelector('.icon');
            
            
            if (token) {
                fetch('/api/wishlists/', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => {
                    if (response.ok) {
                        return response.json();
                    }
                    return [];
                })
                .then(wishlists => {
                    const wishlistIds = wishlists.map(w => w.product);
                    isLiked = wishlistIds.includes(currentProduct.product_id);
                    if (favIcon) favIcon.textContent = isLiked ? '‚ù§Ô∏è' : 'ü§ç';
                    favBtn.classList.toggle('liked', isLiked);
                    
                    // Update localStorage with API data
                    localStorage.setItem(getFavoritesKey(), JSON.stringify(wishlistIds));
                })
                .catch(error => {
                    console.warn('Error checking wishlist:', error);
                    if (favIcon) favIcon.textContent = isLiked ? '‚ù§Ô∏è' : 'ü§ç';
                    favBtn.classList.toggle('liked', isLiked);
                });
            } else {
                if (favIcon) favIcon.textContent = isLiked ? '‚ù§Ô∏è' : 'ü§ç';
                favBtn.classList.toggle('liked', isLiked);
            }
            
            favBtn.onclick = (e) => toggleFavorite(e, currentProduct.product_id);
            
            // cart button handler and state
            const inCart = isInCart(currentProduct.product_id);
            cartBtn.classList.toggle('in-cart', inCart);
            cartBtn.innerHTML = inCart ? '<span class="icon">‚úì</span>' : '<span class="icon">üõí</span>';
            cartBtn.onclick = (e) => addToCart(e, currentProduct.product_id);
            
            // Update rating stars display
            const ratingStarsEl = document.getElementById('modal-rating-stars');
            if (ratingStarsEl && currentProduct.rating) {
                const stars = Math.round(currentProduct.rating);
                const starStr = '‚òÖ'.repeat(Math.min(stars, 5)) + '‚òÜ'.repeat(Math.max(0, 5 - stars));
                ratingStarsEl.textContent = `${starStr} (${currentProduct.rating}/5)`;
            } else if (ratingStarsEl) {
                ratingStarsEl.textContent = '–ù–µ—Ç –æ—Ü–µ–Ω–æ–∫';
            }

            const thumbnails = document.getElementById('modal-thumbnails');
            thumbnails.innerHTML = validImages.map((img, idx) => `
                <div class="modal-thumbnail ${idx === 0 ? 'active' : ''}" onclick="switchImage(${idx}, '${img.replace(/'/g, "\\'")}')">
                    <img src="${img}" alt="–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ${idx + 1}">
                </div>
            `).join('');

            const specsContainer = document.getElementById('specs-container');
            const specs = currentProduct.specifications || {};
            
            specsContainer.innerHTML = Object.entries(specs).map(([key, value]) => {
                let displayValue = value;
                if (Array.isArray(value)) {
                    displayValue = value.join('\n\n');
                }
                
                const label = getLabelForKey(key);
                return `
                    <div class="spec-item">
                        <div class="spec-label">${label}</div>
                        <div class="spec-value">${displayValue}</div>
                    </div>
                `;
            }).join('');

            document.getElementById('specs-modal').classList.add('active');
        }

        function getCompareList() {
            return JSON.parse(localStorage.getItem(getCompareKey()) || '[]');
        }

        function isCompared(productId) {
            const list = getCompareList();
            return list.includes(parseInt(productId));
        }

        function updateCompareButton(btn, productId) {
            if (!btn) return;
            if (isCompared(productId)) {
                btn.textContent = '–í —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏';
                btn.classList.add('in-compare');
            } else {
                btn.textContent = '–°—Ä–∞–≤–Ω–∏—Ç—å';
                btn.classList.remove('in-compare');
            }
        }

        function toggleCompare(event) {
            event.stopPropagation();
            const btn = event.currentTarget || event.target;
            const productId = btn.dataset.productId || (currentProduct && currentProduct.product_id);
            if (!productId) return;

            let list = getCompareList();
            const id = parseInt(productId);
            const product = getProductById(id);
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –Ω–µ –ø—É—Å—Ç–æ–π
            if (!list.includes(id) && list.length > 0 && product) {
                const firstCompareId = list[0];
                const firstProduct = getProductById(firstCompareId);
                const currentTemplate = getProductCategory(product);
                const firstTemplate = firstProduct ? getProductCategory(firstProduct) : null;
                if (currentTemplate !== firstTemplate) {
                    alert('‚ùå –ù–µ–ª—å–∑—è —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å —Ç–æ–≤–∞—Ä—ã —Ä–∞–∑–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π!\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä—ã –æ–¥–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.');
                    return;
                }
            }
            if (list.includes(id)) {
                list = list.filter(x => x !== id);
            } else {
                list.push(id);
            }
            localStorage.setItem(getCompareKey(), JSON.stringify(list));
            updateCompareButton(btn, id);
            if (list.includes(id)) {
                window.location.href = '/comparison/';
            }
        }

        function switchImage(index, imageSrc) {
            document.getElementById('modal-main-img').src = imageSrc;
            document.querySelectorAll('.modal-thumbnail').forEach((thumb, i) => {
                thumb.classList.toggle('active', i === index);
            });
        }

        function closeModal() {
            document.getElementById('specs-modal').classList.remove('active');
        }

        function openReviewsModal() {
            if (!currentProduct) return;
            const reviewsModal = document.getElementById('reviews-modal');
            const reviewsList = document.getElementById('reviews-list');
            reviewsList.innerHTML = '<div>–ó–∞–≥—Ä—É–∑–∫–∞ –æ—Ç–∑—ã–≤–æ–≤...</div>';
            reviewsModal.style.display = 'flex';

            fetch(`/api/reviews/?product=${currentProduct.product_id}`)
                .then(res => res.ok ? res.json() : Promise.reject('API error'))
                .then(data => {
                    const reviews = Array.isArray(data) ? data : (data.results || []);
                    if (!reviews.length) {
                        reviewsList.innerHTML = '<div>–ù–µ—Ç –æ—Ç–∑—ã–≤–æ–≤</div>';
                        return;
                    }
                    reviewsList.innerHTML = reviews.map(r => `
                        <div style="border:1px solid #ddd;padding:0.75rem;margin-bottom:0.5rem;border-radius:6px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                                <strong>${r.customer?.email || '–ê–Ω–æ–Ω–∏–º'}</strong>
                                <span style="color:#ffa500;font-size:1.1rem;">‚òÖ ${r.rating}/5</span>
                            </div>
                            <div>${r.reviews_comment || '–ë–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è'}</div>
                            <div style="font-size:0.85rem;color:#999;margin-top:0.5rem;">${new Date(r.publication_date).toLocaleDateString('ru-RU')}</div>
                        </div>
                    `).join('');
                })
                .catch(e => {
                    console.error(e);
                    reviewsList.innerHTML = '<div>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –æ—Ç–∑—ã–≤–æ–≤</div>';
                });
        }
        
        function removeFromCart(productId) {
            let cart = JSON.parse(localStorage.getItem(getCartKey()) || '[]');
            cart = cart.filter(item => item.product_id !== productId);
            localStorage.setItem(getCartKey(), JSON.stringify(cart));
            loadCartItems();
            updateCartCounter();
        }

        function closeReviewsModal() {
            document.getElementById('reviews-modal').style.display = 'none';
        }

        // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ
        document.getElementById('specs-modal').addEventListener('click', (e) => {
            if (e.target.id === 'specs-modal') closeModal();
        });

        // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
        const searchInput = document.getElementById('search');
        
        // –ì–æ—Ä—è—á–∞—è –∫–ª–∞–≤–∏—à–∞ / –¥–ª—è —Ñ–æ–∫—É—Å–∞ –Ω–∞ –ø–æ–∏—Å–∫
        document.addEventListener('keydown', function(e) {
            const isInput = e.target.tagName === 'INPUT' || 
                           e.target.tagName === 'TEXTAREA' || 
                           e.target.isContentEditable;
            
            // –°–ª—ç—à –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –ø–æ–∏—Å–∫—É (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞)
            if (e.key === '/' && !isInput) {
                e.preventDefault();
                if (searchInput) {
                    searchInput.focus();
                    searchInput.select();
                }
            }
        });
        
        searchInput.addEventListener('input', (e) => {
            applyFilters();
        });

        function applySort(products) {
            const sortValue = document.getElementById('sort')?.value || '';
            let sorted = [...products];

            switch(sortValue) {
                case 'price-asc':
                    sorted.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
                    break;
                case 'price-desc':
                    sorted.sort((a, b) => parseFloat(b.price) - parseFloat(a.price));
                    break;
                case 'name':
                    sorted.sort((a, b) => a.product_name.localeCompare(b.product_name));
                    break;
            }

            renderProducts(sorted);
        }

        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–æ–≤
        function toggleFilterGroup(header) {
            header.classList.toggle('open');
            const options = header.nextElementSibling;
            if (options) {
                options.style.display = options.style.display === 'none' ? 'block' : 'none';
            }
        }

        async function applyFilters() {
            let filtered = [];
            if (serverPaged) {
                try {
                    const pageProducts = await fetchServerPage(currentPage);
                    filtered = pageProducts.slice();
                } catch (e) {
                    console.error('Server page fetch failed', e);
                    filtered = getFilteredProductsByCategory();
                }
            } else {
                filtered = getFilteredProductsByCategory();
            }

            // –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ
            const minPrice = parseFloat(document.getElementById('price-min').value) || 0;
            const maxPrice = parseFloat(document.getElementById('price-max').value) || Infinity;
            
            filtered = filtered.filter(p => {
                const price = parseFloat(p.price);
                return price >= minPrice && price <= maxPrice;
            });

            // –§–∏–ª—å—Ç—Ä –ø–æ –Ω–∞–ª–∏—á–∏—é
            const stockFilters = Array.from(document.querySelectorAll('.filter-checkbox:not([data-spec-key])')).filter(cb => {
                const parent = cb.closest('.filter-group');
                return parent && parent.querySelector('.filter-header').textContent.includes('–ù–∞–ª–∏—á–∏–µ') && cb.checked;
            });

            if (stockFilters.length > 0) {
                const hasInStock = stockFilters.some(cb => cb.value === 'in-stock');
                const hasOutOfStock = stockFilters.some(cb => cb.value === 'out-of-stock');
                
                if (hasInStock && !hasOutOfStock) {
                    filtered = filtered.filter(p => p.stock_quantity > 0);
                } else if (hasOutOfStock && !hasInStock) {
                    filtered = filtered.filter(p => p.stock_quantity === 0);
                }
            }

            // –§–∏–ª—å—Ç—Ä –ø–æ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è–º
            const specFilters = {};
            document.querySelectorAll('.filter-checkbox[data-spec-key]:checked').forEach(cb => {
                const key = cb.dataset.specKey;
                const value = cb.value;
                if (!specFilters[key]) specFilters[key] = [];
                specFilters[key].push(value);
            });

            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–π
            Object.entries(specFilters).forEach(([key, values]) => {
                filtered = filtered.filter(p => {
                    const specs = p.specifications || {};
                    
                    // –î–ª—è –º–æ–Ω–∏—Ç–æ—Ä–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º –æ–±–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –∫–ª—é—á–µ–π (diagonal/size, matrix/panel_type)
                    let specValue = specs[key];
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∫–ª—é—á–∏ –¥–ª—è diagonal/size –∏ matrix/panel_type
                    if (key === 'diagonal' && !specValue) {
                        specValue = specs['size']; // –ò—â–µ–º –ø–æ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–º—É –∫–ª—é—á—É
                    } else if (key === 'size' && !specValue) {
                        specValue = specs['diagonal'];
                    } else if (key === 'matrix' && !specValue) {
                        specValue = specs['panel_type'];
                    } else if (key === 'panel_type' && !specValue) {
                        specValue = specs['matrix'];
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ (—É—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –∫–∞–≤—ã—á–∫–∏)
                    const normalizeValue = (val) => {
                        if (!val) return '';
                        const str = String(val).trim().replace(/^["']|["']$/g, '');
                        return str;
                    };
                    
                    if (Array.isArray(specValue)) {
                        return values.some(v => specValue.some(sv => normalizeValue(sv) === normalizeValue(v)));
                    } else if (specValue) {
                        return values.some(v => normalizeValue(specValue) === normalizeValue(v));
                    }
                    return false;
                });
            });

            // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–∏—Å–∫ –∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É
            const searchTerm = document.getElementById('search').value.toLowerCase();
            filtered = filtered.filter(p => p.product_name.toLowerCase().includes(searchTerm));

            applySort(filtered);
            updateFilterCounts();
        }

        function resetAllFilters() {
            document.getElementById('price-min').value = '';
            document.getElementById('price-max').value = '';
            document.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('search').value = '';
            currentPage = 1;
            renderProducts(getFilteredProductsByCategory());
            updateFilterCounts();
        }

        function generateDynamicFilters() {
            const container = document.getElementById('dynamic-filters');
            container.innerHTML = '';

            // Build specs from products of the currently selected category only
            const specsByKey = {};
            const filteredByCategory = getFilteredProductsByCategory();

            filteredByCategory.forEach(product => {
                const specs = product.specifications || {};
                Object.entries(specs).forEach(([key, value]) => {
                    // –ú–∞–ø–ø–∏–Ω–≥ –∫–ª—é—á–µ–π –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: size -> diagonal, panel_type -> matrix
                    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –æ–±–æ–∏—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∫–ª—é—á–µ–π –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–æ–≤
                    let mappedKey = key;
                    
                    // –ú–∞–ø–ø–∏–º —Å—Ç–∞—Ä—ã–µ –∫–ª—é—á–∏ –Ω–∞ –Ω–æ–≤—ã–µ (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏)
                    if (key === 'size' || key === 'diagonal') {
                        mappedKey = 'diagonal';
                    } else if (key === 'panel_type' || key === 'matrix') {
                        mappedKey = 'matrix';
                    }
                    
                    if (!specsByKey[mappedKey]) specsByKey[mappedKey] = new Set();

                    if (Array.isArray(value)) {
                        value.forEach(v => { 
                            if (v && typeof v === 'string') {
                                // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –≤ –Ω–∞—á–∞–ª–µ/–∫–æ–Ω—Ü–µ –∏ –ª–∏—à–Ω–∏–µ –∫–∞–≤—ã—á–∫–∏
                                const cleaned = v.trim().replace(/^["']|["']$/g, '');
                                if (cleaned) specsByKey[mappedKey].add(cleaned);
                            }
                        });
                    } else if (value !== null && value !== undefined) {
                        // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –≤ –Ω–∞—á–∞–ª–µ/–∫–æ–Ω—Ü–µ –∏ –ª–∏—à–Ω–∏–µ –∫–∞–≤—ã—á–∫–∏
                        const cleaned = String(value).trim().replace(/^["']|["']$/g, '');
                        if (cleaned) specsByKey[mappedKey].add(cleaned);
                    }
                });
            });

            // –ù–∞–∑–≤–∞–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤
            const labels = {
                'cpu': '–ü—Ä–æ—Ü–µ—Å—Å–æ—Ä',
                'gpu': '–í–∏–¥–µ–æ–∫–∞—Ä—Ç–∞',
                'ram': '–û–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –ø–∞–º—è—Ç—å (–ì–ë)',
                'brand': '–ë—Ä–µ–Ω–¥',
                'model': '–ú–æ–¥–µ–ª—å',
                'layout': '–§–æ—Ä–º–∞—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã',
                'backlight': '–ü–æ–¥—Å–≤–µ—Ç–∫–∞',
                'mechanical': '–ú–µ—Ö–∞–Ω–∏—á–µ—Å–∫–∞—è',
                'connection': '–¢–∏–ø –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è',
                'dpi': 'DPI',
                'buttons': '–ö–Ω–æ–ø–∫–∏',
                'ports': '–ü–æ—Ä—Ç—ã –∏ —Ä–∞–∑—ä–µ–º—ã',
                'battery': '–ë–∞—Ç–∞—Ä–µ—è',
                'display': '–¢–∏–ø —ç–∫—Ä–∞–Ω–∞',
                'storage': '–•—Ä–∞–Ω–∏–ª–∏—â–µ (–ì–ë)',
                'resolution': '–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ',
                'refresh_rate': '–ß–∞—Å—Ç–æ—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è',
                'diagonal': '–î–∏–∞–≥–æ–Ω–∞–ª—å',
                'matrix': '–ú–∞—Ç—Ä–∏—Ü–∞',
                'panel_type': '–¢–∏–ø –º–∞—Ç—Ä–∏—Ü—ã',
                'size': '–î–∏–∞–≥–æ–Ω–∞–ª—å (–¥—é–π–º)',
                '1q': '–î–∏–∞–≥–æ–Ω–∞–ª—å —ç–∫—Ä–∞–Ω–∞ (–¥—é–π–º)',
                '44': '–û–±—ä–µ–º –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–π –ø–∞–º—è—Ç–∏ (–ì–ë)',
                '4op': '–ò–≥—Ä–æ–≤–æ–π –Ω–æ—É—Ç–±—É–∫',
                '1go': '–ú–æ–¥–µ–ª—å –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–π –≤–∏–¥–µ–æ–∫–∞—Ä—Ç—ã',
                '1gf': '–õ–∏–Ω–µ–π–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞',
                '1gt': '–û–±—ä–µ–º SSD (–ì–ë)',
                'al': '–û–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞',
                '32s': '–õ–∏–Ω–µ–π–∫–∞',
                '2d': '–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞',
                '1gg': '–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞',
                '1gd': '–¢–∏–ø —ç–∫—Ä–∞–Ω–∞'
            };

            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫–ª—é—á–∏ –¥–ª—è –ø–æ—Ä—è–¥–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
            const priorityByCategory = {
                'monitors': ['brand', 'model', 'diagonal', 'matrix', 'panel_type', 'size', 'resolution', 'refresh_rate', 'ports'],
                'all': ['brand', 'cpu', 'gpu', 'ram', 'storage', 'display', 'model', 'ports', 'battery']
            };
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            let priority = priorityByCategory['all'];
            if (currentCategory === 'monitors') {
                priority = priorityByCategory['monitors'];
            }
            
            const sortedKeys = [
                ...priority.filter(k => specsByKey[k]),
                ...Object.keys(specsByKey).filter(k => !priority.includes(k)).sort()
            ];

            // If a specific category is selected, limit keys to those defined in templates for that category
            let allowedKeysSet = null;
            if (currentCategory && currentCategory !== 'all') {
                allowedKeysSet = new Set();
                const types = categoriesMap[currentCategory] || [];
                types.forEach(t => {
                    const s = templatesMap[t];
                    if (s) {
                        s.forEach(k => allowedKeysSet.add(k));
                    }
                });
                
                // –î–ª—è –º–æ–Ω–∏—Ç–æ—Ä–æ–≤ –¥–æ–±–∞–≤–ª—è–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∫–ª—é—á–∏ (diagonal/matrix –∏ size/panel_type)
                // –í—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º diagonal –∏ matrix, –µ—Å–ª–∏ –µ—Å—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ
                if (allowedKeysSet.has('size') || specsByKey['diagonal']) {
                    allowedKeysSet.add('diagonal');
                }
                if (allowedKeysSet.has('panel_type') || specsByKey['matrix']) {
                    allowedKeysSet.add('matrix');
                }
                // –¢–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º size –∏ panel_type –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                if (specsByKey['size']) allowedKeysSet.add('size');
                if (specsByKey['panel_type']) allowedKeysSet.add('panel_type');
            }

            // –°–æ–∑–¥–∞—ë–º —Ñ–∏–ª—å—Ç—Ä—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª—é—á–∞
            sortedKeys.forEach(key => {
                if (allowedKeysSet && !allowedKeysSet.has(key)) return; // skip keys not relevant to category
                const values = Array.from(specsByKey[key]).sort();
                
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–π –∏–ª–∏ –ø—É—Å—Ç–æ
                if (values.length === 0 || values.length > 50) return;

                const filterHTML = `
                    <div class="filter-group">
                        <div class="filter-header" onclick="toggleFilterGroup(this)">
                            <span>${getLabelForKey(key)}</span>
                            <div class="arrow"></div>
                        </div>
                        <div class="filter-options" style="display: none;">
                            ${values.map(value => `
                                <label>
                                    <input type="checkbox" value="${value}" class="filter-checkbox" data-spec-key="${key}">
                                    ${value} <span class="filter-count">(0)</span>
                                </label>
                            `).join('')}
                        </div>
                    </div>
                `;

                container.innerHTML += filterHTML;
            });
        }

        function updateFilterCounts() {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á—ë—Ç—á–∏–∫–∏ –≤ —Ñ–∏–ª—å—Ç—Ä–∞—Ö
            const inStockCount = allProducts.filter(p => p.stock_quantity > 0).length;
            const outOfStockCount = allProducts.filter(p => p.stock_quantity === 0).length;

            // –û–±–Ω–æ–≤–ª—è–µ–º span'—ã —Å —á–∏—Å–ª–∞–º–∏ –¥–ª—è –±–∞–∑–æ–≤—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤
            const counts = {
                'in-stock': inStockCount,
                'out-of-stock': outOfStockCount
            };

            document.querySelectorAll('.filter-checkbox:not([data-spec-key])').forEach(cb => {
                const countSpan = cb.closest('label').querySelector('.filter-count');
                if (countSpan && counts[cb.value] !== undefined) {
                    countSpan.textContent = `(${counts[cb.value]})`;
                }
            });

            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á—ë—Ç—á–∏–∫–∏ –¥–ª—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤
            document.querySelectorAll('.filter-checkbox[data-spec-key]').forEach(cb => {
                const key = cb.dataset.specKey;
                const value = cb.value;
                const countSpan = cb.closest('label').querySelector('.filter-count');
                
                if (countSpan) {
                    const count = getFilteredProductsByCategory().filter(p => {
                        const specs = p.specifications || {};
                        
                        // –î–ª—è –º–æ–Ω–∏—Ç–æ—Ä–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º –æ–±–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –∫–ª—é—á–µ–π (diagonal/size, matrix/panel_type)
                        let specValue = specs[key];
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –∫–ª—é—á–∏ –¥–ª—è diagonal/size –∏ matrix/panel_type
                        if (key === 'diagonal' && !specValue) {
                            specValue = specs['size']; // –ò—â–µ–º –ø–æ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–º—É –∫–ª—é—á—É
                        } else if (key === 'size' && !specValue) {
                            specValue = specs['diagonal'];
                        } else if (key === 'matrix' && !specValue) {
                            specValue = specs['panel_type'];
                        } else if (key === 'panel_type' && !specValue) {
                            specValue = specs['matrix'];
                        }
                        
                        // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è (—É–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –∫–∞–≤—ã—á–∫–∏)
                        const normalizeValue = (val) => {
                            if (!val) return '';
                            const str = String(val).trim().replace(/^["']|["']$/g, '');
                            return str;
                        };
                        
                        if (Array.isArray(specValue)) return specValue.some(v => normalizeValue(v) === normalizeValue(value));
                        else if (specValue) return normalizeValue(specValue) === normalizeValue(value);
                        return false;
                    }).length;
                    
                    countSpan.textContent = `(${count})`;
                }
            });
        }

        // ----------------------
        // Category handling
        // ----------------------
        const categoriesMap = {
            'all': [],
            'notebooks': ['laptop'],
            'monitors': ['monitor'],
            'peripherals': ['keyboard','mouse'],
            'keyboards': ['keyboard'],
            'mice': ['mouse']
        };

        let currentCategory = 'all';

        function getProductCategory(prod) {
            // Prioritize template field (from DB category), fall back to type/category fields
            const template = (prod.template || '').toString().toLowerCase();
            if (template) return template;
            return (prod.type || prod.product_type || prod.category || prod.category_name || '').toString().toLowerCase();
        }

        function getFilteredProductsByCategory() {
            if (currentCategory === 'all') return allProducts.slice();
            const allowed = categoriesMap[currentCategory] || [];
            return allProducts.filter(p => allowed.includes(getProductCategory(p)));
        }

        function generateCategorySelector() {
            const sel = document.getElementById('category-selector');
            const cats = [
                {id:'all', label:'–í—Å–µ'},
                {id:'notebooks', label:'–ù–æ—É—Ç–±—É–∫–∏'},
                {id:'monitors', label:'–ú–æ–Ω–∏—Ç–æ—Ä—ã'},
                {id:'peripherals', label:'–ü–µ—Ä–∏—Ñ–µ—Ä–∏—è'},
                {id:'keyboards', label:'–ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã'},
                {id:'mice', label:'–ú—ã—à–∏'}
            ];
            sel.innerHTML = cats.map(c => `<button class="cat-btn" data-cat="${c.id}">${c.label}</button>`).join(' ');
            sel.querySelectorAll('.cat-btn').forEach(btn => {
                btn.onclick = () => { currentCategory = btn.dataset.cat; currentPage = 1; applyFilters(); generateDynamicFilters(); updateFilterCounts(); updateActiveCategory(); };
            });
            updateActiveCategory();
        }

        function updateActiveCategory() {
            document.querySelectorAll('#category-selector .cat-btn').forEach(b => b.classList.toggle('active', b.dataset.cat === currentCategory));
        }

        function openProductReviews(productId) {
            window.location.href = `/reviews/?product_id=${productId}`;
        }

        // Initialize category selector after products load

        // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        loadProducts();

    </script>
{% endblock %}
